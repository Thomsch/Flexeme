digraph  {
m1_22 [cluster="System.Collections.Generic.IEnumerable<TSource>.IndexOf<TSource>(System.Func<TSource, bool>)", file="Parser.cs", label="Entry System.Collections.Generic.IEnumerable<TSource>.IndexOf<TSource>(System.Func<TSource, bool>)", span="36-36"];
m1_24 [cluster="System.Collections.Generic.IEnumerable<TSource>.TakeWhile<TSource>(System.Func<TSource, bool>)", file="Parser.cs", label="Entry System.Collections.Generic.IEnumerable<TSource>.TakeWhile<TSource>(System.Func<TSource, bool>)", span="0-0"];
m1_35 [cluster="Unk.Take", file="Parser.cs", label="Entry Unk.Take", span=""];
m1_3 [cluster="System.Collections.Generic.IEnumerable<TSource>.Pairwise<TSource, TResult>(System.Func<TSource, TSource, TResult>)", file="Parser.cs", label="Entry System.Collections.Generic.IEnumerable<TSource>.Pairwise<TSource, TResult>(System.Func<TSource, TSource, TResult>)", span="10-10"];
m1_15 [cluster="System.Collections.Generic.IEnumerable<TSource>.Concat<TSource>(System.Collections.Generic.IEnumerable<TSource>)", file="Parser.cs", label="Entry System.Collections.Generic.IEnumerable<TSource>.Concat<TSource>(System.Collections.Generic.IEnumerable<TSource>)", span="0-0"];
m1_36 [cluster="lambda expression", file="Parser.cs", label="Entry lambda expression", span="35-35"];
m1_5 [cluster="lambda expression", file="Parser.cs", label="f.IsName() && s.IsValue()\r\n                            ? typeLookup(f.Text).Return(info =>\r\n                                   info.TargetType == TargetType.Sequence\r\n                                        ? new[] { f }.Concat(tokens.OfSequence(f, info))\r\n                                        : new Token[] { }, new Token[] { })\r\n                            : new Token[] { }", span="17-22"];
m1_12 [cluster="lambda expression", file="Parser.cs", label="info.TargetType == TargetType.Sequence\r\n                                        ? new[] { f }.Concat(tokens.OfSequence(f, info))\r\n                                        : new Token[] { }", span="19-21"];
m1_4 [cluster="lambda expression", file="Parser.cs", label="Entry lambda expression", span="16-22"];
m1_6 [cluster="lambda expression", file="Parser.cs", label="Exit lambda expression", span="16-22"];
m1_11 [cluster="lambda expression", file="Parser.cs", label="Entry lambda expression", span="18-21"];
m1_13 [cluster="lambda expression", file="Parser.cs", label="Exit lambda expression", span="18-21"];
m1_26 [cluster="lambda expression", file="Parser.cs", label="t.Equals(nameToken)", span="29-29"];
m1_30 [cluster="lambda expression", file="Parser.cs", label="info.MaxItems.Return(\r\n                            n => tokens.Skip(nameIndex + 1).Take(n),\r\n                                 tokens.Skip(nameIndex + 1).TakeWhile(v => v.IsValue()))", span="33-35"];
m1_33 [cluster="lambda expression", file="Parser.cs", label="tokens.Skip(nameIndex + 1).Take(n)", span="34-34"];
m1_25 [cluster="lambda expression", file="Parser.cs", label="Entry lambda expression", span="29-29"];
m1_29 [cluster="lambda expression", file="Parser.cs", label="Entry lambda expression", span="33-35"];
m1_39 [cluster="lambda expression", file="Parser.cs", label="Entry lambda expression", span="36-36"];
m1_27 [cluster="lambda expression", file="Parser.cs", label="Exit lambda expression", span="29-29"];
m1_31 [cluster="lambda expression", file="Parser.cs", label="Exit lambda expression", span="33-35"];
m1_32 [cluster="lambda expression", file="Parser.cs", label="Entry lambda expression", span="34-34"];
m1_34 [cluster="lambda expression", file="Parser.cs", label="Exit lambda expression", span="34-34"];
m1_37 [cluster="lambda expression", file="Parser.cs", label="v.IsValue()", span="35-35"];
m1_38 [cluster="lambda expression", file="Parser.cs", label="Exit lambda expression", span="35-35"];
m1_40 [cluster="lambda expression", file="Parser.cs", label="v.IsValue()", span="36-36"];
m1_41 [cluster="lambda expression", file="Parser.cs", label="Exit lambda expression", span="36-36"];
m1_10 [cluster="Unk.Return", file="Parser.cs", label="Entry Unk.Return", span=""];
m1_28 [cluster="CommandLine.Core.Token.Equals(CommandLine.Core.Token)", file="Parser.cs", label="Entry CommandLine.Core.Token.Equals(CommandLine.Core.Token)", span="55-55"];
m1_23 [cluster="System.Collections.Generic.IEnumerable<TSource>.Skip<TSource>(int)", file="Parser.cs", label="Entry System.Collections.Generic.IEnumerable<TSource>.Skip<TSource>(int)", span="0-0"];
m1_16 [cluster="CommandLine.Core.Sequence.OfSequence(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, CommandLine.Core.Token, CommandLine.Core.TypeDescriptor)", file="Parser.cs", label="Entry CommandLine.Core.Sequence.OfSequence(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, CommandLine.Core.Token, CommandLine.Core.TypeDescriptor)", span="27-27"];
m1_17 [cluster="CommandLine.Core.Sequence.OfSequence(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, CommandLine.Core.Token, CommandLine.Core.TypeDescriptor)", file="Parser.cs", label="var nameIndex = tokens.IndexOf(t => t.Equals(nameToken))", span="29-29"];
m1_19 [cluster="CommandLine.Core.Sequence.OfSequence(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, CommandLine.Core.Token, CommandLine.Core.TypeDescriptor)", file="Parser.cs", label="return info.NextValue.Return(\r\n                    _ => info.MaxItems.Return(\r\n                            n => tokens.Skip(nameIndex + 1).Take(n),\r\n                                 tokens.Skip(nameIndex + 1).TakeWhile(v => v.IsValue())),\r\n                    tokens.Skip(nameIndex + 1).TakeWhile(v => v.IsValue()));", span="32-36"];
m1_18 [cluster="CommandLine.Core.Sequence.OfSequence(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, CommandLine.Core.Token, CommandLine.Core.TypeDescriptor)", file="Parser.cs", label="nameIndex >= 0", span="30-30"];
m1_20 [cluster="CommandLine.Core.Sequence.OfSequence(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, CommandLine.Core.Token, CommandLine.Core.TypeDescriptor)", file="Parser.cs", label="return new Token[] { };", span="38-38"];
m1_21 [cluster="CommandLine.Core.Sequence.OfSequence(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, CommandLine.Core.Token, CommandLine.Core.TypeDescriptor)", file="Parser.cs", label="Exit CommandLine.Core.Sequence.OfSequence(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, CommandLine.Core.Token, CommandLine.Core.TypeDescriptor)", span="27-27"];
m1_7 [cluster="CommandLine.Core.Token.IsName()", file="Parser.cs", label="Entry CommandLine.Core.Token.IsName()", span="68-68"];
m1_8 [cluster="CommandLine.Core.Token.IsValue()", file="Parser.cs", label="Entry CommandLine.Core.Token.IsValue()", span="73-73"];
m1_9 [cluster="System.Func<T, TResult>.Invoke(T)", file="Parser.cs", label="Entry System.Func<T, TResult>.Invoke(T)", span="0-0"];
m1_14 [cluster="Unk.OfSequence", file="Parser.cs", label="Entry Unk.OfSequence", span=""];
m1_0 [cluster="CommandLine.Core.Sequence.Partition(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, System.Func<string, Maybe<CommandLine.Core.TypeDescriptor>>)", file="Parser.cs", label="Entry CommandLine.Core.Sequence.Partition(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, System.Func<string, Maybe<CommandLine.Core.TypeDescriptor>>)", span="11-11"];
m1_1 [cluster="CommandLine.Core.Sequence.Partition(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, System.Func<string, Maybe<CommandLine.Core.TypeDescriptor>>)", file="Parser.cs", label="return from tseq in tokens.Pairwise(\r\n                (f, s) =>\r\n                        f.IsName() && s.IsValue()\r\n                            ? typeLookup(f.Text).Return(info =>\r\n                                   info.TargetType == TargetType.Sequence\r\n                                        ? new[] { f }.Concat(tokens.OfSequence(f, info))\r\n                                        : new Token[] { }, new Token[] { })\r\n                            : new Token[] { })\r\n                   from t in tseq\r\n                   select t;", span="15-24"];
m1_2 [cluster="CommandLine.Core.Sequence.Partition(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, System.Func<string, Maybe<CommandLine.Core.TypeDescriptor>>)", file="Parser.cs", label="Exit CommandLine.Core.Sequence.Partition(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, System.Func<string, Maybe<CommandLine.Core.TypeDescriptor>>)", span="11-11"];
m1_42 [file="Parser.cs", label="System.Collections.Generic.IEnumerable<CommandLine.Core.Token>", span=""];
m1_43 [file="Parser.cs", label="System.Func<string, Maybe<CommandLine.Core.TypeDescriptor>>", span=""];
m1_44 [file="Parser.cs", label="CommandLine.Core.Token", span=""];
m1_45 [file="Parser.cs", label="CommandLine.Core.Token", span=""];
m1_46 [file="Parser.cs", label="System.Collections.Generic.IEnumerable<CommandLine.Core.Token>", span=""];
m1_47 [file="Parser.cs", label="CommandLine.Core.TypeDescriptor", span=""];
m1_48 [file="Parser.cs", label=nameIndex, span=""];
m2_11 [cluster="CommandLine.Infrastructure.Maybe.Nothing<T>()", file="ParserResult.cs", label="Entry CommandLine.Infrastructure.Maybe.Nothing<T>()", span="66-66"];
m2_10 [cluster="System.Collections.Generic.IEnumerable<TSource>.Contains<TSource>(TSource)", file="ParserResult.cs", label="Entry System.Collections.Generic.IEnumerable<TSource>.Contains<TSource>(TSource)", span="0-0"];
m2_5 [cluster="CommandLine.Core.Scalar.Partition(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, System.Func<string, CommandLine.Infrastructure.Maybe<CommandLine.Core.TypeDescriptor>>)", file="ParserResult.cs", label="Entry CommandLine.Core.Scalar.Partition(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, System.Func<string, CommandLine.Infrastructure.Maybe<CommandLine.Core.TypeDescriptor>>)", span="11-11"];
m2_13 [cluster="CommandLine.Infrastructure.Maybe.Just<T>(T)", file="ParserResult.cs", label="Entry CommandLine.Infrastructure.Maybe.Just<T>(T)", span="71-71"];
m2_14 [cluster="CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values()", file="ParserResult.cs", label="Entry CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values()", span="28-28"];
m2_16 [cluster="CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values()", color=green, community=0, file="ParserResult.cs", label="var result = Scalar.Partition(\r\n                new []\r\n                    {\r\n                        Token.Name(''str''), Token.Value(''strvalue''), Token.Value(''freevalue''),\r\n                        Token.Name(''x''), Token.Value(''freevalue2'')\r\n                    },\r\n                name =>\r\n                    new[] { ''str'', ''int'' }.Contains(name)\r\n                        ? Maybe.Just(TypeDescriptor.Create(TypeDescriptorKind.Scalar, Maybe.Nothing<int>()))\r\n                        : Maybe.Nothing<TypeDescriptor>())", prediction=0, span="32-41"];
m2_15 [cluster="CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values()", file="ParserResult.cs", label="var expected = new [] { Token.Name(''str''), Token.Value(''strvalue'') }", span="30-30"];
m2_17 [cluster="CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values()", color=green, community=0, file="ParserResult.cs", label="expected.ShouldAllBeEquivalentTo(result)", prediction=1, span="43-43"];
m2_18 [cluster="CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values()", file="ParserResult.cs", label="Exit CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values()", span="28-28"];
m2_0 [cluster="CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values_from_empty_token_sequence()", file="ParserResult.cs", label="Entry CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values_from_empty_token_sequence()", span="13-13"];
m2_1 [cluster="CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values_from_empty_token_sequence()", color=green, community=0, file="ParserResult.cs", label="var expected = new Token[] { }", prediction=2, span="15-15"];
m2_2 [cluster="CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values_from_empty_token_sequence()", color=green, community=0, file="ParserResult.cs", label="var result = Scalar.Partition(\r\n                new Token[] { },\r\n                name =>\r\n                    new[] { ''str'', ''int'' }.Contains(name)\r\n                        ? Maybe.Just(TypeDescriptor.Create(TypeDescriptorKind.Scalar, Maybe.Nothing<int>()))\r\n                        : Maybe.Nothing<TypeDescriptor>())", prediction=3, span="17-22"];
m2_3 [cluster="CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values_from_empty_token_sequence()", color=green, community=0, file="ParserResult.cs", label="expected.ShouldAllBeEquivalentTo(result)", prediction=2, span="24-24"];
m2_4 [cluster="CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values_from_empty_token_sequence()", file="ParserResult.cs", label="Exit CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values_from_empty_token_sequence()", span="13-13"];
m2_6 [cluster="Unk.ShouldAllBeEquivalentTo", file="ParserResult.cs", label="Entry Unk.ShouldAllBeEquivalentTo", span=""];
m2_21 [cluster="lambda expression", file="ParserResult.cs", label="Entry lambda expression", span="38-41"];
m2_7 [cluster="lambda expression", file="ParserResult.cs", label="Entry lambda expression", span="19-22"];
m2_8 [cluster="lambda expression", color=green, community=0, file="ParserResult.cs", label="new[] { ''str'', ''int'' }.Contains(name)\r\n                        ? Maybe.Just(TypeDescriptor.Create(TypeDescriptorKind.Scalar, Maybe.Nothing<int>()))\r\n                        : Maybe.Nothing<TypeDescriptor>()", prediction=5, span="20-22"];
m2_9 [cluster="lambda expression", file="ParserResult.cs", label="Exit lambda expression", span="19-22"];
m2_22 [cluster="lambda expression", file="ParserResult.cs", label="new[] { ''str'', ''int'' }.Contains(name)\r\n                        ? Maybe.Just(TypeDescriptor.Create(TypeDescriptorKind.Scalar, Maybe.Nothing<int>()))\r\n                        : Maybe.Nothing<TypeDescriptor>()", span="39-41"];
m2_23 [cluster="lambda expression", file="ParserResult.cs", label="Exit lambda expression", span="38-41"];
m2_12 [cluster="CommandLine.Core.TypeDescriptor.Create(CommandLine.Core.TypeDescriptorKind, CommandLine.Infrastructure.Maybe<int>)", file="ParserResult.cs", label="Entry CommandLine.Core.TypeDescriptor.Create(CommandLine.Core.TypeDescriptorKind, CommandLine.Infrastructure.Maybe<int>)", span="36-36"];
m2_19 [cluster="CommandLine.Core.Token.Name(string)", file="ParserResult.cs", label="Entry CommandLine.Core.Token.Name(string)", span="19-19"];
m2_20 [cluster="CommandLine.Core.Token.Value(string)", file="ParserResult.cs", label="Entry CommandLine.Core.Token.Value(string)", span="24-24"];
m3_0 [cluster="CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string)", file="ParserTests.cs", label="Entry CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string)", span="18-18"];
m3_1 [cluster="CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string)", file="ParserTests.cs", label="Exit CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string)", span="18-18"];
m3_2 [cluster="CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string)", file="ParserTests.cs", label="Entry CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string)", span="29-29"];
m3_3 [cluster="CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string)", file="ParserTests.cs", label="Exit CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string)", span="29-29"];
m3_8 [cluster="CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string, string, string)", file="ParserTests.cs", label="Entry CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string, string, string)", span="68-68"];
m3_9 [cluster="CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string, string, string)", file="ParserTests.cs", label="Exit CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string, string, string)", span="68-68"];
m3_6 [cluster="CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string, string)", file="ParserTests.cs", label="Entry CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string, string)", span="54-54"];
m3_7 [cluster="CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string, string)", file="ParserTests.cs", label="Exit CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string, string)", span="54-54"];
m3_4 [cluster="CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string)", file="ParserTests.cs", label="Entry CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string)", span="41-41"];
m3_5 [cluster="CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string)", file="ParserTests.cs", label="Exit CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string)", span="41-41"];
m1_5 -> m1_11  [color=darkseagreen4, key=1, label="lambda expression", style=dashed];
m1_4 -> m1_12  [color=darkseagreen4, key=1, label="CommandLine.Core.Token", style=dashed];
m1_30 -> m1_32  [color=darkseagreen4, key=1, label="lambda expression", style=dashed];
m1_30 -> m1_36  [color=darkseagreen4, key=1, label="lambda expression", style=dashed];
m1_16 -> m1_26  [color=darkseagreen4, key=1, label="CommandLine.Core.Token", style=dashed];
m1_16 -> m1_19  [color=darkseagreen4, key=1, label="System.Collections.Generic.IEnumerable<CommandLine.Core.Token>", style=dashed];
m1_16 -> m1_30  [color=darkseagreen4, key=1, label="System.Collections.Generic.IEnumerable<CommandLine.Core.Token>", style=dashed];
m1_16 -> m1_33  [color=darkseagreen4, key=1, label="System.Collections.Generic.IEnumerable<CommandLine.Core.Token>", style=dashed];
m1_17 -> m1_25  [color=darkseagreen4, key=1, label="lambda expression", style=dashed];
m1_17 -> m1_19  [color=darkseagreen4, key=1, label=nameIndex, style=dashed];
m1_17 -> m1_30  [color=darkseagreen4, key=1, label=nameIndex, style=dashed];
m1_17 -> m1_33  [color=darkseagreen4, key=1, label=nameIndex, style=dashed];
m1_19 -> m1_29  [color=darkseagreen4, key=1, label="lambda expression", style=dashed];
m1_19 -> m1_39  [color=darkseagreen4, key=1, label="lambda expression", style=dashed];
m1_0 -> m1_5  [color=darkseagreen4, key=1, label="System.Collections.Generic.IEnumerable<CommandLine.Core.Token>", style=dashed];
m1_0 -> m1_12  [color=darkseagreen4, key=1, label="System.Collections.Generic.IEnumerable<CommandLine.Core.Token>", style=dashed];
m1_1 -> m1_4  [color=darkseagreen4, key=1, label="lambda expression", style=dashed];
m1_1 -> m1_1  [color=darkseagreen4, key=1, label=tseq, style=dashed];
m1_42 -> m1_5  [color=darkseagreen4, key=1, label="System.Collections.Generic.IEnumerable<CommandLine.Core.Token>", style=dashed];
m1_42 -> m1_12  [color=darkseagreen4, key=1, label="System.Collections.Generic.IEnumerable<CommandLine.Core.Token>", style=dashed];
m1_43 -> m1_5  [color=darkseagreen4, key=1, label="System.Func<string, Maybe<CommandLine.Core.TypeDescriptor>>", style=dashed];
m1_44 -> m1_12  [color=darkseagreen4, key=1, label="CommandLine.Core.Token", style=dashed];
m1_45 -> m1_26  [color=darkseagreen4, key=1, label="CommandLine.Core.Token", style=dashed];
m1_46 -> m1_30  [color=darkseagreen4, key=1, label="System.Collections.Generic.IEnumerable<CommandLine.Core.Token>", style=dashed];
m1_46 -> m1_33  [color=darkseagreen4, key=1, label="System.Collections.Generic.IEnumerable<CommandLine.Core.Token>", style=dashed];
m1_47 -> m1_30  [color=darkseagreen4, key=1, label="CommandLine.Core.TypeDescriptor", style=dashed];
m1_48 -> m1_30  [color=darkseagreen4, key=1, label=nameIndex, style=dashed];
m1_48 -> m1_33  [color=darkseagreen4, key=1, label=nameIndex, style=dashed];
m2_16 -> m2_21  [color=green, key=1, label="lambda expression", style=dashed];
m2_15 -> m2_17  [color=green, key=1, label=expected, style=dashed];
m2_1 -> m2_3  [color=green, key=1, label=expected, style=dashed];
m2_2 -> m2_7  [color=green, key=1, label="lambda expression", style=dashed];
}
