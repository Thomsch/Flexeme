digraph  {
m1_22 [label="Entry System.Collections.Generic.IEnumerable<TSource>.IndexOf<TSource>(System.Func<TSource, bool>)", span="36-36", cluster="System.Collections.Generic.IEnumerable<TSource>.IndexOf<TSource>(System.Func<TSource, bool>)", file="Parser.cs"];
m1_24 [label="Entry System.Collections.Generic.IEnumerable<TSource>.TakeWhile<TSource>(System.Func<TSource, bool>)", span="0-0", cluster="System.Collections.Generic.IEnumerable<TSource>.TakeWhile<TSource>(System.Func<TSource, bool>)", file="Parser.cs"];
m1_35 [label="Entry Unk.Take", span="", cluster="Unk.Take", file="Parser.cs"];
m1_3 [label="Entry System.Collections.Generic.IEnumerable<TSource>.Pairwise<TSource, TResult>(System.Func<TSource, TSource, TResult>)", span="10-10", cluster="System.Collections.Generic.IEnumerable<TSource>.Pairwise<TSource, TResult>(System.Func<TSource, TSource, TResult>)", file="Parser.cs"];
m1_15 [label="Entry System.Collections.Generic.IEnumerable<TSource>.Concat<TSource>(System.Collections.Generic.IEnumerable<TSource>)", span="0-0", cluster="System.Collections.Generic.IEnumerable<TSource>.Concat<TSource>(System.Collections.Generic.IEnumerable<TSource>)", file="Parser.cs"];
m1_36 [label="Entry lambda expression", span="35-35", cluster="lambda expression", file="Parser.cs"];
m1_5 [label="f.IsName() && s.IsValue()\r\n                            ? typeLookup(f.Text).Return(info =>\r\n                                   info.TargetType == TargetType.Sequence\r\n                                        ? new[] { f }.Concat(tokens.OfSequence(f, info))\r\n                                        : new Token[] { }, new Token[] { })\r\n                            : new Token[] { }", span="17-22", cluster="lambda expression", file="Parser.cs"];
m1_12 [label="info.TargetType == TargetType.Sequence\r\n                                        ? new[] { f }.Concat(tokens.OfSequence(f, info))\r\n                                        : new Token[] { }", span="19-21", cluster="lambda expression", file="Parser.cs"];
m1_4 [label="Entry lambda expression", span="16-22", cluster="lambda expression", file="Parser.cs"];
m1_6 [label="Exit lambda expression", span="16-22", cluster="lambda expression", file="Parser.cs"];
m1_11 [label="Entry lambda expression", span="18-21", cluster="lambda expression", file="Parser.cs"];
m1_13 [label="Exit lambda expression", span="18-21", cluster="lambda expression", file="Parser.cs"];
m1_26 [label="t.Equals(nameToken)", span="29-29", cluster="lambda expression", file="Parser.cs"];
m1_30 [label="info.MaxItems.Return(\r\n                            n => tokens.Skip(nameIndex + 1).Take(n),\r\n                                 tokens.Skip(nameIndex + 1).TakeWhile(v => v.IsValue()))", span="33-35", cluster="lambda expression", file="Parser.cs"];
m1_33 [label="tokens.Skip(nameIndex + 1).Take(n)", span="34-34", cluster="lambda expression", file="Parser.cs"];
m1_25 [label="Entry lambda expression", span="29-29", cluster="lambda expression", file="Parser.cs"];
m1_29 [label="Entry lambda expression", span="33-35", cluster="lambda expression", file="Parser.cs"];
m1_39 [label="Entry lambda expression", span="36-36", cluster="lambda expression", file="Parser.cs"];
m1_27 [label="Exit lambda expression", span="29-29", cluster="lambda expression", file="Parser.cs"];
m1_31 [label="Exit lambda expression", span="33-35", cluster="lambda expression", file="Parser.cs"];
m1_32 [label="Entry lambda expression", span="34-34", cluster="lambda expression", file="Parser.cs"];
m1_34 [label="Exit lambda expression", span="34-34", cluster="lambda expression", file="Parser.cs"];
m1_37 [label="v.IsValue()", span="35-35", cluster="lambda expression", file="Parser.cs"];
m1_38 [label="Exit lambda expression", span="35-35", cluster="lambda expression", file="Parser.cs"];
m1_40 [label="v.IsValue()", span="36-36", cluster="lambda expression", file="Parser.cs"];
m1_41 [label="Exit lambda expression", span="36-36", cluster="lambda expression", file="Parser.cs"];
m1_10 [label="Entry Unk.Return", span="", cluster="Unk.Return", file="Parser.cs"];
m1_28 [label="Entry CommandLine.Core.Token.Equals(CommandLine.Core.Token)", span="55-55", cluster="CommandLine.Core.Token.Equals(CommandLine.Core.Token)", file="Parser.cs"];
m1_23 [label="Entry System.Collections.Generic.IEnumerable<TSource>.Skip<TSource>(int)", span="0-0", cluster="System.Collections.Generic.IEnumerable<TSource>.Skip<TSource>(int)", file="Parser.cs"];
m1_16 [label="Entry CommandLine.Core.Sequence.OfSequence(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, CommandLine.Core.Token, CommandLine.Core.TypeDescriptor)", span="27-27", cluster="CommandLine.Core.Sequence.OfSequence(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, CommandLine.Core.Token, CommandLine.Core.TypeDescriptor)", file="Parser.cs"];
m1_17 [label="var nameIndex = tokens.IndexOf(t => t.Equals(nameToken))", span="29-29", cluster="CommandLine.Core.Sequence.OfSequence(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, CommandLine.Core.Token, CommandLine.Core.TypeDescriptor)", file="Parser.cs"];
m1_19 [label="return info.NextValue.Return(\r\n                    _ => info.MaxItems.Return(\r\n                            n => tokens.Skip(nameIndex + 1).Take(n),\r\n                                 tokens.Skip(nameIndex + 1).TakeWhile(v => v.IsValue())),\r\n                    tokens.Skip(nameIndex + 1).TakeWhile(v => v.IsValue()));", span="32-36", cluster="CommandLine.Core.Sequence.OfSequence(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, CommandLine.Core.Token, CommandLine.Core.TypeDescriptor)", file="Parser.cs"];
m1_18 [label="nameIndex >= 0", span="30-30", cluster="CommandLine.Core.Sequence.OfSequence(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, CommandLine.Core.Token, CommandLine.Core.TypeDescriptor)", file="Parser.cs"];
m1_20 [label="return new Token[] { };", span="38-38", cluster="CommandLine.Core.Sequence.OfSequence(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, CommandLine.Core.Token, CommandLine.Core.TypeDescriptor)", file="Parser.cs"];
m1_21 [label="Exit CommandLine.Core.Sequence.OfSequence(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, CommandLine.Core.Token, CommandLine.Core.TypeDescriptor)", span="27-27", cluster="CommandLine.Core.Sequence.OfSequence(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, CommandLine.Core.Token, CommandLine.Core.TypeDescriptor)", file="Parser.cs"];
m1_7 [label="Entry CommandLine.Core.Token.IsName()", span="68-68", cluster="CommandLine.Core.Token.IsName()", file="Parser.cs"];
m1_8 [label="Entry CommandLine.Core.Token.IsValue()", span="73-73", cluster="CommandLine.Core.Token.IsValue()", file="Parser.cs"];
m1_9 [label="Entry System.Func<T, TResult>.Invoke(T)", span="0-0", cluster="System.Func<T, TResult>.Invoke(T)", file="Parser.cs"];
m1_14 [label="Entry Unk.OfSequence", span="", cluster="Unk.OfSequence", file="Parser.cs"];
m1_0 [label="Entry CommandLine.Core.Sequence.Partition(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, System.Func<string, Maybe<CommandLine.Core.TypeDescriptor>>)", span="11-11", cluster="CommandLine.Core.Sequence.Partition(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, System.Func<string, Maybe<CommandLine.Core.TypeDescriptor>>)", file="Parser.cs"];
m1_1 [label="return from tseq in tokens.Pairwise(\r\n                (f, s) =>\r\n                        f.IsName() && s.IsValue()\r\n                            ? typeLookup(f.Text).Return(info =>\r\n                                   info.TargetType == TargetType.Sequence\r\n                                        ? new[] { f }.Concat(tokens.OfSequence(f, info))\r\n                                        : new Token[] { }, new Token[] { })\r\n                            : new Token[] { })\r\n                   from t in tseq\r\n                   select t;", span="15-24", cluster="CommandLine.Core.Sequence.Partition(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, System.Func<string, Maybe<CommandLine.Core.TypeDescriptor>>)", file="Parser.cs"];
m1_2 [label="Exit CommandLine.Core.Sequence.Partition(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, System.Func<string, Maybe<CommandLine.Core.TypeDescriptor>>)", span="11-11", cluster="CommandLine.Core.Sequence.Partition(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, System.Func<string, Maybe<CommandLine.Core.TypeDescriptor>>)", file="Parser.cs"];
m1_42 [label="System.Collections.Generic.IEnumerable<CommandLine.Core.Token>", span="", file="Parser.cs"];
m1_43 [label="System.Func<string, Maybe<CommandLine.Core.TypeDescriptor>>", span="", file="Parser.cs"];
m1_44 [label="CommandLine.Core.Token", span="", file="Parser.cs"];
m1_45 [label="CommandLine.Core.Token", span="", file="Parser.cs"];
m1_46 [label="System.Collections.Generic.IEnumerable<CommandLine.Core.Token>", span="", file="Parser.cs"];
m1_47 [label="CommandLine.Core.TypeDescriptor", span="", file="Parser.cs"];
m1_48 [label=nameIndex, span="", file="Parser.cs"];
m2_11 [label="Entry CommandLine.Infrastructure.Maybe.Nothing<T>()", span="66-66", cluster="CommandLine.Infrastructure.Maybe.Nothing<T>()", file="ParserResult.cs"];
m2_10 [label="Entry System.Collections.Generic.IEnumerable<TSource>.Contains<TSource>(TSource)", span="0-0", cluster="System.Collections.Generic.IEnumerable<TSource>.Contains<TSource>(TSource)", file="ParserResult.cs"];
m2_5 [label="Entry CommandLine.Core.Scalar.Partition(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, System.Func<string, CommandLine.Infrastructure.Maybe<CommandLine.Core.TypeDescriptor>>)", span="11-11", cluster="CommandLine.Core.Scalar.Partition(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, System.Func<string, CommandLine.Infrastructure.Maybe<CommandLine.Core.TypeDescriptor>>)", file="ParserResult.cs"];
m2_13 [label="Entry CommandLine.Infrastructure.Maybe.Just<T>(T)", span="71-71", cluster="CommandLine.Infrastructure.Maybe.Just<T>(T)", file="ParserResult.cs"];
m2_14 [label="Entry CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values()", span="28-28", cluster="CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values()", file="ParserResult.cs"];
m2_16 [label="var result = Scalar.Partition(\r\n                new []\r\n                    {\r\n                        Token.Name(''str''), Token.Value(''strvalue''), Token.Value(''freevalue''),\r\n                        Token.Name(''x''), Token.Value(''freevalue2'')\r\n                    },\r\n                name =>\r\n                    new[] { ''str'', ''int'' }.Contains(name)\r\n                        ? Maybe.Just(TypeDescriptor.Create(TypeDescriptorKind.Scalar, Maybe.Nothing<int>()))\r\n                        : Maybe.Nothing<TypeDescriptor>())", span="32-41", cluster="CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values()", color=green, community=0, file="ParserResult.cs"];
m2_15 [label="var expected = new [] { Token.Name(''str''), Token.Value(''strvalue'') }", span="30-30", cluster="CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values()", file="ParserResult.cs"];
m2_17 [label="expected.ShouldAllBeEquivalentTo(result)", span="43-43", cluster="CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values()", color=green, community=0, file="ParserResult.cs"];
m2_18 [label="Exit CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values()", span="28-28", cluster="CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values()", file="ParserResult.cs"];
m2_0 [label="Entry CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values_from_empty_token_sequence()", span="13-13", cluster="CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values_from_empty_token_sequence()", file="ParserResult.cs"];
m2_1 [label="var expected = new Token[] { }", span="15-15", cluster="CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values_from_empty_token_sequence()", color=green, community=0, file="ParserResult.cs"];
m2_2 [label="var result = Scalar.Partition(\r\n                new Token[] { },\r\n                name =>\r\n                    new[] { ''str'', ''int'' }.Contains(name)\r\n                        ? Maybe.Just(TypeDescriptor.Create(TypeDescriptorKind.Scalar, Maybe.Nothing<int>()))\r\n                        : Maybe.Nothing<TypeDescriptor>())", span="17-22", cluster="CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values_from_empty_token_sequence()", color=green, community=0, file="ParserResult.cs"];
m2_3 [label="expected.ShouldAllBeEquivalentTo(result)", span="24-24", cluster="CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values_from_empty_token_sequence()", color=green, community=0, file="ParserResult.cs"];
m2_4 [label="Exit CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values_from_empty_token_sequence()", span="13-13", cluster="CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values_from_empty_token_sequence()", file="ParserResult.cs"];
m2_6 [label="Entry Unk.ShouldAllBeEquivalentTo", span="", cluster="Unk.ShouldAllBeEquivalentTo", file="ParserResult.cs"];
m2_21 [label="Entry lambda expression", span="38-41", cluster="lambda expression", file="ParserResult.cs"];
m2_7 [label="Entry lambda expression", span="19-22", cluster="lambda expression", file="ParserResult.cs"];
m2_8 [label="new[] { ''str'', ''int'' }.Contains(name)\r\n                        ? Maybe.Just(TypeDescriptor.Create(TypeDescriptorKind.Scalar, Maybe.Nothing<int>()))\r\n                        : Maybe.Nothing<TypeDescriptor>()", span="20-22", cluster="lambda expression", color=green, community=0, file="ParserResult.cs"];
m2_9 [label="Exit lambda expression", span="19-22", cluster="lambda expression", file="ParserResult.cs"];
m2_22 [label="new[] { ''str'', ''int'' }.Contains(name)\r\n                        ? Maybe.Just(TypeDescriptor.Create(TypeDescriptorKind.Scalar, Maybe.Nothing<int>()))\r\n                        : Maybe.Nothing<TypeDescriptor>()", span="39-41", cluster="lambda expression", file="ParserResult.cs"];
m2_23 [label="Exit lambda expression", span="38-41", cluster="lambda expression", file="ParserResult.cs"];
m2_12 [label="Entry CommandLine.Core.TypeDescriptor.Create(CommandLine.Core.TypeDescriptorKind, CommandLine.Infrastructure.Maybe<int>)", span="36-36", cluster="CommandLine.Core.TypeDescriptor.Create(CommandLine.Core.TypeDescriptorKind, CommandLine.Infrastructure.Maybe<int>)", file="ParserResult.cs"];
m2_19 [label="Entry CommandLine.Core.Token.Name(string)", span="19-19", cluster="CommandLine.Core.Token.Name(string)", file="ParserResult.cs"];
m2_20 [label="Entry CommandLine.Core.Token.Value(string)", span="24-24", cluster="CommandLine.Core.Token.Value(string)", file="ParserResult.cs"];
m3_0 [label="Entry CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string)", span="18-18", cluster="CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string)", file="ParserTests.cs"];
m3_1 [label="Exit CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string)", span="18-18", cluster="CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string)", file="ParserTests.cs"];
m3_2 [label="Entry CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string)", span="29-29", cluster="CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string)", file="ParserTests.cs"];
m3_3 [label="Exit CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string)", span="29-29", cluster="CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string)", file="ParserTests.cs"];
m3_8 [label="Entry CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string, string, string)", span="68-68", cluster="CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string, string, string)", file="ParserTests.cs"];
m3_9 [label="Exit CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string, string, string)", span="68-68", cluster="CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string, string, string)", file="ParserTests.cs"];
m3_6 [label="Entry CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string, string)", span="54-54", cluster="CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string, string)", file="ParserTests.cs"];
m3_7 [label="Exit CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string, string)", span="54-54", cluster="CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string, string)", file="ParserTests.cs"];
m3_4 [label="Entry CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string)", span="41-41", cluster="CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string)", file="ParserTests.cs"];
m3_5 [label="Exit CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string)", span="41-41", cluster="CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string)", file="ParserTests.cs"];
m1_36 -> m1_37  [key=0, style=solid];
m1_5 -> m1_6  [key=0, style=solid];
m1_5 -> m1_7  [key=2, style=dotted];
m1_5 -> m1_8  [key=2, style=dotted];
m1_5 -> m1_9  [key=2, style=dotted];
m1_5 -> m1_10  [key=2, style=dotted];
m1_5 -> m1_11  [key=1, style=dashed, color=darkseagreen4, label="lambda expression"];
m1_12 -> m1_13  [key=0, style=solid];
m1_12 -> m1_14  [key=2, style=dotted];
m1_12 -> m1_15  [key=2, style=dotted];
m1_4 -> m1_5  [key=0, style=solid];
m1_4 -> m1_12  [key=1, style=dashed, color=darkseagreen4, label="CommandLine.Core.Token"];
m1_6 -> m1_4  [key=0, style=bold, color=blue];
m1_11 -> m1_12  [key=0, style=solid];
m1_13 -> m1_11  [key=0, style=bold, color=blue];
m1_26 -> m1_27  [key=0, style=solid];
m1_26 -> m1_28  [key=2, style=dotted];
m1_30 -> m1_31  [key=0, style=solid];
m1_30 -> m1_23  [key=2, style=dotted];
m1_30 -> m1_24  [key=2, style=dotted];
m1_30 -> m1_10  [key=2, style=dotted];
m1_30 -> m1_32  [key=1, style=dashed, color=darkseagreen4, label="lambda expression"];
m1_30 -> m1_36  [key=1, style=dashed, color=darkseagreen4, label="lambda expression"];
m1_33 -> m1_34  [key=0, style=solid];
m1_33 -> m1_23  [key=2, style=dotted];
m1_33 -> m1_35  [key=2, style=dotted];
m1_25 -> m1_26  [key=0, style=solid];
m1_29 -> m1_30  [key=0, style=solid];
m1_39 -> m1_40  [key=0, style=solid];
m1_27 -> m1_25  [key=0, style=bold, color=blue];
m1_31 -> m1_29  [key=0, style=bold, color=blue];
m1_32 -> m1_33  [key=0, style=solid];
m1_34 -> m1_32  [key=0, style=bold, color=blue];
m1_37 -> m1_38  [key=0, style=solid];
m1_37 -> m1_8  [key=2, style=dotted];
m1_38 -> m1_36  [key=0, style=bold, color=blue];
m1_40 -> m1_41  [key=0, style=solid];
m1_40 -> m1_8  [key=2, style=dotted];
m1_41 -> m1_39  [key=0, style=bold, color=blue];
m1_16 -> m1_17  [key=0, style=solid];
m1_16 -> m1_26  [key=1, style=dashed, color=darkseagreen4, label="CommandLine.Core.Token"];
m1_16 -> m1_19  [key=1, style=dashed, color=darkseagreen4, label="System.Collections.Generic.IEnumerable<CommandLine.Core.Token>"];
m1_16 -> m1_30  [key=1, style=dashed, color=darkseagreen4, label="System.Collections.Generic.IEnumerable<CommandLine.Core.Token>"];
m1_16 -> m1_33  [key=1, style=dashed, color=darkseagreen4, label="System.Collections.Generic.IEnumerable<CommandLine.Core.Token>"];
m1_17 -> m1_18  [key=0, style=solid];
m1_17 -> m1_22  [key=2, style=dotted];
m1_17 -> m1_25  [key=1, style=dashed, color=darkseagreen4, label="lambda expression"];
m1_17 -> m1_19  [key=1, style=dashed, color=darkseagreen4, label=nameIndex];
m1_17 -> m1_30  [key=1, style=dashed, color=darkseagreen4, label=nameIndex];
m1_17 -> m1_33  [key=1, style=dashed, color=darkseagreen4, label=nameIndex];
m1_19 -> m1_21  [key=0, style=solid];
m1_19 -> m1_23  [key=2, style=dotted];
m1_19 -> m1_24  [key=2, style=dotted];
m1_19 -> m1_10  [key=2, style=dotted];
m1_19 -> m1_29  [key=1, style=dashed, color=darkseagreen4, label="lambda expression"];
m1_19 -> m1_39  [key=1, style=dashed, color=darkseagreen4, label="lambda expression"];
m1_18 -> m1_19  [key=0, style=solid];
m1_18 -> m1_20  [key=0, style=solid];
m1_20 -> m1_21  [key=0, style=solid];
m1_21 -> m1_16  [key=0, style=bold, color=blue];
m1_0 -> m1_1  [key=0, style=solid];
m1_0 -> m1_5  [key=1, style=dashed, color=darkseagreen4, label="System.Collections.Generic.IEnumerable<CommandLine.Core.Token>"];
m1_0 -> m1_12  [key=1, style=dashed, color=darkseagreen4, label="System.Collections.Generic.IEnumerable<CommandLine.Core.Token>"];
m1_1 -> m1_2  [key=0, style=solid];
m1_1 -> m1_3  [key=2, style=dotted];
m1_1 -> m1_4  [key=1, style=dashed, color=darkseagreen4, label="lambda expression"];
m1_1 -> m1_1  [key=1, style=dashed, color=darkseagreen4, label=tseq];
m1_2 -> m1_0  [key=0, style=bold, color=blue];
m1_42 -> m1_5  [key=1, style=dashed, color=darkseagreen4, label="System.Collections.Generic.IEnumerable<CommandLine.Core.Token>"];
m1_42 -> m1_12  [key=1, style=dashed, color=darkseagreen4, label="System.Collections.Generic.IEnumerable<CommandLine.Core.Token>"];
m1_43 -> m1_5  [key=1, style=dashed, color=darkseagreen4, label="System.Func<string, Maybe<CommandLine.Core.TypeDescriptor>>"];
m1_44 -> m1_12  [key=1, style=dashed, color=darkseagreen4, label="CommandLine.Core.Token"];
m1_45 -> m1_26  [key=1, style=dashed, color=darkseagreen4, label="CommandLine.Core.Token"];
m1_46 -> m1_30  [key=1, style=dashed, color=darkseagreen4, label="System.Collections.Generic.IEnumerable<CommandLine.Core.Token>"];
m1_46 -> m1_33  [key=1, style=dashed, color=darkseagreen4, label="System.Collections.Generic.IEnumerable<CommandLine.Core.Token>"];
m1_47 -> m1_30  [key=1, style=dashed, color=darkseagreen4, label="CommandLine.Core.TypeDescriptor"];
m1_48 -> m1_30  [key=1, style=dashed, color=darkseagreen4, label=nameIndex];
m1_48 -> m1_33  [key=1, style=dashed, color=darkseagreen4, label=nameIndex];
m2_14 -> m2_15  [key=0, style=solid];
m2_16 -> m2_17  [key=0, style=solid, color=green];
m2_16 -> m2_19  [key=2, style=dotted, color=green];
m2_16 -> m2_20  [key=2, style=dotted, color=green];
m2_16 -> m2_5  [key=2, style=dotted, color=green];
m2_16 -> m2_21  [key=1, style=dashed, color=green, label="lambda expression"];
m2_15 -> m2_16  [key=0, style=solid, color=green];
m2_15 -> m2_17  [key=1, style=dashed, color=green, label=expected];
m2_15 -> m2_19  [key=2, style=dotted];
m2_15 -> m2_20  [key=2, style=dotted];
m2_17 -> m2_18  [key=0, style=solid, color=green];
m2_17 -> m2_6  [key=2, style=dotted, color=green];
m2_18 -> m2_14  [key=0, style=bold, color=blue];
m2_0 -> m2_1  [key=0, style=solid, color=green];
m2_1 -> m2_2  [key=0, style=solid, color=green];
m2_1 -> m2_3  [key=1, style=dashed, color=green, label=expected];
m2_2 -> m2_3  [key=0, style=solid, color=green];
m2_2 -> m2_5  [key=2, style=dotted, color=green];
m2_2 -> m2_7  [key=1, style=dashed, color=green, label="lambda expression"];
m2_3 -> m2_4  [key=0, style=solid, color=green];
m2_3 -> m2_6  [key=2, style=dotted, color=green];
m2_4 -> m2_0  [key=0, style=bold, color=blue];
m2_21 -> m2_22  [key=0, style=solid];
m2_7 -> m2_8  [key=0, style=solid, color=green];
m2_8 -> m2_9  [key=0, style=solid, color=green];
m2_8 -> m2_10  [key=2, style=dotted, color=green];
m2_8 -> m2_11  [key=2, style=dotted, color=green];
m2_8 -> m2_12  [key=2, style=dotted, color=green];
m2_8 -> m2_13  [key=2, style=dotted, color=green];
m2_9 -> m2_7  [key=0, style=bold, color=blue];
m2_22 -> m2_10  [key=2, style=dotted];
m2_22 -> m2_11  [key=2, style=dotted];
m2_22 -> m2_12  [key=2, style=dotted];
m2_22 -> m2_13  [key=2, style=dotted];
m2_22 -> m2_23  [key=0, style=solid];
m2_23 -> m2_21  [key=0, style=bold, color=blue];
m3_0 -> m3_1  [key=0, style=solid];
m3_1 -> m3_0  [key=0, style=bold, color=blue];
m3_2 -> m3_3  [key=0, style=solid];
m3_3 -> m3_2  [key=0, style=bold, color=blue];
m3_8 -> m3_9  [key=0, style=solid];
m3_9 -> m3_8  [key=0, style=bold, color=blue];
m3_6 -> m3_7  [key=0, style=solid];
m3_7 -> m3_6  [key=0, style=bold, color=blue];
m3_4 -> m3_5  [key=0, style=solid];
m3_5 -> m3_4  [key=0, style=bold, color=blue];
}
