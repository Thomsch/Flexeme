digraph  {
m2_0 [cluster="CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values_from_empty_token_sequence()", file="TokenPartitioner.cs", label="Entry CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values_from_empty_token_sequence()", span="13-13"];
m2_1 [cluster="CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values_from_empty_token_sequence()", color=green, community=0, file="TokenPartitioner.cs", label="var expected = new Token[] { }", prediction=0, span="15-15"];
m2_2 [cluster="CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values_from_empty_token_sequence()", file="TokenPartitioner.cs", label="var result = Scalar.Partition(\r\n                new Token[] { },\r\n                name =>\r\n                    new[] { ''str'', ''int'' }.Contains(name)\r\n                        ? Maybe.Just(TypeDescriptor.Create(TargetType.Scalar, Maybe.Nothing<int>()))\r\n                        : Maybe.Nothing<TypeDescriptor>())", span="17-22"];
m2_3 [cluster="CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values_from_empty_token_sequence()", file="TokenPartitioner.cs", label="expected.ShouldBeEquivalentTo(result)", span="24-24"];
m2_4 [cluster="CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values_from_empty_token_sequence()", file="TokenPartitioner.cs", label="Exit CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values_from_empty_token_sequence()", span="13-13"];
m2_5 [cluster="CommandLine.Core.Scalar.Partition(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, System.Func<string, CSharpx.Maybe<CommandLine.Core.TypeDescriptor>>)", file="TokenPartitioner.cs", label="Entry CommandLine.Core.Scalar.Partition(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, System.Func<string, CSharpx.Maybe<CommandLine.Core.TypeDescriptor>>)", span="12-12"];
m2_6 [cluster="Unk.ShouldBeEquivalentTo", file="TokenPartitioner.cs", label="Entry Unk.ShouldBeEquivalentTo", span=""];
m2_7 [cluster="lambda expression", file="TokenPartitioner.cs", label="Entry lambda expression", span="19-22"];
m2_9 [cluster="lambda expression", file="TokenPartitioner.cs", label="Exit lambda expression", span="19-22"];
m2_10 [cluster="System.Collections.Generic.IEnumerable<T>.Memorize<T>()", file="TokenPartitioner.cs", label="Entry System.Collections.Generic.IEnumerable<T>.Memorize<T>()", span="374-374"];
m2_26 [cluster="System.Collections.Generic.IEnumerable<TSource>.Contains<TSource>(TSource)", file="TokenPartitioner.cs", label="Entry System.Collections.Generic.IEnumerable<TSource>.Contains<TSource>(TSource)", span="0-0"];
m2_19 [cluster="System.Collections.Generic.IEnumerable<TSource>.Concat<TSource>(System.Collections.Generic.IEnumerable<TSource>)", file="TokenPartitioner.cs", label="Entry System.Collections.Generic.IEnumerable<TSource>.Concat<TSource>(System.Collections.Generic.IEnumerable<TSource>)", span="0-0"];
m2_12 [cluster="CommandLine.Core.TypeDescriptor.Create(CommandLine.Core.TargetType, CSharpx.Maybe<int>, CommandLine.Core.TypeDescriptor)", file="TokenPartitioner.cs", label="Entry CommandLine.Core.TypeDescriptor.Create(CommandLine.Core.TargetType, CSharpx.Maybe<int>, CommandLine.Core.TypeDescriptor)", span="35-35"];
m2_18 [cluster="CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values()", file="TokenPartitioner.cs", label="Exit CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values()", span="28-28"];
m2_37 [cluster="Unk.IsValue", file="TokenPartitioner.cs", label="Entry Unk.IsValue", span=""];
m2_20 [cluster="CommandLine.Core.KeyValuePairHelper.ForSequence(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>)", file="TokenPartitioner.cs", label="Entry CommandLine.Core.KeyValuePairHelper.ForSequence(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>)", span="22-22"];
m2_14 [cluster="CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values()", file="TokenPartitioner.cs", label="Entry CommandLine.Tests.Unit.Core.ScalarTests.Partition_scalar_values()", span="28-28"];
m2_22 [cluster="lambda expression", file="TokenPartitioner.cs", label="new[] { ''str'', ''int'' }.Contains(name)\r\n                        ? Maybe.Just(TypeDescriptor.Create(TargetType.Scalar, Maybe.Nothing<int>()))\r\n                        : Maybe.Nothing<TypeDescriptor>()", span="39-41"];
m2_16 [cluster="System.Collections.Generic.IEnumerable<TSource>.Except<TSource>(System.Collections.Generic.IEnumerable<TSource>)", file="TokenPartitioner.cs", label="Entry System.Collections.Generic.IEnumerable<TSource>.Except<TSource>(System.Collections.Generic.IEnumerable<TSource>)", span="0-0"];
m2_17 [cluster="CommandLine.Core.KeyValuePairHelper.ForSwitch(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>)", file="TokenPartitioner.cs", label="Entry CommandLine.Core.KeyValuePairHelper.ForSwitch(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>)", span="10-10"];
m2_15 [cluster="Unk.Memorize", file="TokenPartitioner.cs", label="Entry Unk.Memorize", span=""];
m2_30 [cluster="Unk.Contains", file="TokenPartitioner.cs", label="Entry Unk.Contains", span=""];
m2_13 [cluster="CommandLine.Core.Sequence.Partition(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, System.Func<string, CSharpx.Maybe<CommandLine.Core.TypeDescriptor>>)", file="TokenPartitioner.cs", label="Entry CommandLine.Core.Sequence.Partition(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, System.Func<string, CSharpx.Maybe<CommandLine.Core.TypeDescriptor>>)", span="12-12"];
m2_21 [cluster="Unk.Select", file="TokenPartitioner.cs", label="Entry Unk.Select", span=""];
m2_24 [cluster="lambda expression", file="TokenPartitioner.cs", label="!switches.Contains(t)", span="21-21"];
m2_28 [cluster="lambda expression", file="TokenPartitioner.cs", label="!scalars.Contains(t)", span="22-22"];
m2_32 [cluster="lambda expression", file="TokenPartitioner.cs", label="!sequences.Contains(t)", span="23-23"];
m2_23 [cluster="lambda expression", file="TokenPartitioner.cs", label="Exit lambda expression", span="38-41"];
m2_27 [cluster="lambda expression", file="TokenPartitioner.cs", label="Entry lambda expression", span="22-22"];
m2_31 [cluster="lambda expression", file="TokenPartitioner.cs", label="Entry lambda expression", span="23-23"];
m2_34 [cluster="lambda expression", file="TokenPartitioner.cs", label="Entry lambda expression", span="24-24"];
m2_38 [cluster="lambda expression", file="TokenPartitioner.cs", label="Entry lambda expression", span="31-31"];
m2_25 [cluster="lambda expression", file="TokenPartitioner.cs", label="Exit lambda expression", span="21-21"];
m2_29 [cluster="lambda expression", file="TokenPartitioner.cs", label="Exit lambda expression", span="22-22"];
m2_33 [cluster="lambda expression", file="TokenPartitioner.cs", label="Exit lambda expression", span="23-23"];
m2_35 [cluster="lambda expression", file="TokenPartitioner.cs", label="v.IsValue()", span="24-24"];
m2_36 [cluster="lambda expression", file="TokenPartitioner.cs", label="Exit lambda expression", span="24-24"];
m2_39 [cluster="lambda expression", file="TokenPartitioner.cs", label="t.Text", span="31-31"];
m2_40 [cluster="lambda expression", file="TokenPartitioner.cs", label="Exit lambda expression", span="31-31"];
m2_11 [cluster="CommandLine.Core.Switch.Partition(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, System.Func<string, CSharpx.Maybe<CommandLine.Core.TypeDescriptor>>)", file="TokenPartitioner.cs", label="Entry CommandLine.Core.Switch.Partition(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, System.Func<string, CSharpx.Maybe<CommandLine.Core.TypeDescriptor>>)", span="11-11"];
m2_41 [file="TokenPartitioner.cs", label=switches, span=""];
m2_42 [file="TokenPartitioner.cs", label=scalars, span=""];
m2_43 [file="TokenPartitioner.cs", label=sequences, span=""];
m2_0 -> m2_3  [color=darkseagreen4, key=1, label="System.Func<string, CSharpx.Maybe<CommandLine.Core.TypeDescriptor>>", style=dashed];
m2_0 -> m2_4  [color=darkseagreen4, key=1, label="System.Func<string, CSharpx.Maybe<CommandLine.Core.TypeDescriptor>>", style=dashed];
m2_1 -> m2_3  [color=green, key=1, label=expected, style=dashed];
m2_1 -> m2_4  [color=darkseagreen4, key=1, label=tokenList, style=dashed];
m2_1 -> m2_5  [color=darkseagreen4, key=1, label=tokenList, style=dashed];
m2_2 -> m2_5  [color=darkseagreen4, key=1, label=switches, style=dashed];
m2_2 -> m2_24  [color=darkseagreen4, key=1, label=switches, style=dashed];
m2_2 -> m2_7  [color=darkseagreen4, key=1, label="lambda expression", style=dashed];
m2_3 -> m2_5  [color=darkseagreen4, key=1, label=scalars, style=dashed];
m2_3 -> m2_28  [color=darkseagreen4, key=1, label=scalars, style=dashed];
m2_4 -> m2_32  [color=darkseagreen4, key=1, label=sequences, style=dashed];
m2_5 -> m2_23  [color=darkseagreen4, key=1, label="lambda expression", style=dashed];
m2_5 -> m2_27  [color=darkseagreen4, key=1, label="lambda expression", style=dashed];
m2_5 -> m2_31  [color=darkseagreen4, key=1, label="lambda expression", style=dashed];
m2_5 -> m2_7  [color=darkseagreen4, key=1, label=nonOptions, style=dashed];
m2_6 -> m2_34  [color=darkseagreen4, key=1, label="lambda expression", style=dashed];
m2_16 -> m2_21  [color=darkseagreen4, key=1, label="lambda expression", style=dashed];
m2_15 -> m2_17  [color=darkseagreen4, key=1, label=expected, style=dashed];
m2_41 -> m2_24  [color=darkseagreen4, key=1, label=switches, style=dashed];
m2_42 -> m2_28  [color=darkseagreen4, key=1, label=scalars, style=dashed];
m2_43 -> m2_32  [color=darkseagreen4, key=1, label=sequences, style=dashed];
}
