digraph  {
m0_8 [cluster="CommandLine.Infrastructure.Maybe.Nothing<T>()", file="HelpTextTests.cs", label="Entry CommandLine.Infrastructure.Maybe.Nothing<T>()", span="63-63"];
m0_12 [cluster="Unk.Create", file="HelpTextTests.cs", label="Entry Unk.Create", span=""];
m0_13 [cluster="Unk.Where", file="HelpTextTests.cs", label="Entry Unk.Where", span=""];
m0_6 [cluster="System.Collections.Generic.KeyValuePair<TKey, TValue>.KeyValuePair(TKey, TValue)", file="HelpTextTests.cs", label="Entry System.Collections.Generic.KeyValuePair<TKey, TValue>.KeyValuePair(TKey, TValue)", span="0-0"];
m0_7 [cluster="CommandLine.Core.OptionSpecification.OptionSpecification(string, string, bool, string, CommandLine.Infrastructure.Maybe<int>, CommandLine.Infrastructure.Maybe<int>, char, CommandLine.Infrastructure.Maybe<object>, System.Type, string, string, System.Collections.Generic.IEnumerable<string>)", file="HelpTextTests.cs", label="Entry CommandLine.Core.OptionSpecification.OptionSpecification(string, string, bool, string, CommandLine.Infrastructure.Maybe<int>, CommandLine.Infrastructure.Maybe<int>, char, CommandLine.Infrastructure.Maybe<object>, System.Type, string, string, System.Collections.Generic.IEnumerable<string>)", span="17-17"];
m0_11 [cluster="Unk.Single", file="HelpTextTests.cs", label="Entry Unk.Single", span=""];
m0_15 [cluster="Unk.NotNull", file="HelpTextTests.cs", label="Entry Unk.NotNull", span=""];
m0_27 [cluster="CommandLine.Core.TypeConverter.ChangeType(System.Collections.Generic.IEnumerable<string>, System.Type, bool, System.Globalization.CultureInfo)", file="HelpTextTests.cs", label="Entry CommandLine.Core.TypeConverter.ChangeType(System.Collections.Generic.IEnumerable<string>, System.Type, bool, System.Globalization.CultureInfo)", span="12-12"];
m0_0 [cluster="CommandLine.Tests.Unit.Core.OptionMapperTests.Map_boolean_switch_creates_boolean_value()", file="HelpTextTests.cs", label="Entry CommandLine.Tests.Unit.Core.OptionMapperTests.Map_boolean_switch_creates_boolean_value()", span="16-16"];
m0_1 [cluster="CommandLine.Tests.Unit.Core.OptionMapperTests.Map_boolean_switch_creates_boolean_value()", file="HelpTextTests.cs", label="var tokenPartitions = new[]\r\n                {\r\n                    new KeyValuePair<string, IEnumerable<string>>(''x'', new [] { ''true'' })\r\n                }", span="19-22"];
m0_2 [cluster="CommandLine.Tests.Unit.Core.OptionMapperTests.Map_boolean_switch_creates_boolean_value()", file="HelpTextTests.cs", label="var specProps = new[]\r\n                {\r\n                    SpecificationProperty.Create(\r\n                        new OptionSpecification(''x'', string.Empty, false, string.Empty, Maybe.Nothing<int>(), Maybe.Nothing<int>(), '\0', Maybe.Nothing<object>(), typeof(bool), string.Empty, string.Empty, new List<string>()), \r\n                        typeof(FakeOptions).GetProperties().Single(p => p.Name.Equals(''BoolValue'', StringComparison.Ordinal)),\r\n                        Maybe.Nothing<object>())\r\n                }", span="23-29"];
m0_5 [cluster="CommandLine.Tests.Unit.Core.OptionMapperTests.Map_boolean_switch_creates_boolean_value()", file="HelpTextTests.cs", label="Exit CommandLine.Tests.Unit.Core.OptionMapperTests.Map_boolean_switch_creates_boolean_value()", span="16-16"];
m0_28 [cluster="lambda expression", file="HelpTextTests.cs", label="Entry lambda expression", span="40-42"];
m0_16 [cluster="lambda expression", file="HelpTextTests.cs", label="Entry lambda expression", span="27-27"];
m0_20 [cluster="lambda expression", file="HelpTextTests.cs", label="Entry lambda expression", span="33-33"];
m0_24 [cluster="lambda expression", file="HelpTextTests.cs", label="Entry lambda expression", span="35-35"];
m0_17 [cluster="lambda expression", file="HelpTextTests.cs", label="p.Name.Equals(''BoolValue'', StringComparison.Ordinal)", span="27-27"];
m0_18 [cluster="lambda expression", file="HelpTextTests.cs", label="Exit lambda expression", span="27-27"];
m0_21 [cluster="lambda expression", file="HelpTextTests.cs", label="pt.Specification.IsOption()", span="33-33"];
m0_22 [cluster="lambda expression", file="HelpTextTests.cs", label="Exit lambda expression", span="33-33"];
m0_25 [cluster="lambda expression", file="HelpTextTests.cs", label="TypeConverter.ChangeType(vals, type, isScalar, CultureInfo.InvariantCulture)", span="35-35"];
m0_26 [cluster="lambda expression", file="HelpTextTests.cs", label="Exit lambda expression", span="35-35"];
m0_30 [cluster="lambda expression", file="HelpTextTests.cs", label="Exit lambda expression", span="40-42"];
m0_31 [cluster="string.Equals(string)", file="HelpTextTests.cs", label="Entry string.Equals(string)", span="0-0"];
m0_19 [cluster="string.Equals(string, System.StringComparison)", file="HelpTextTests.cs", label="Entry string.Equals(string, System.StringComparison)", span="0-0"];
m0_23 [cluster="CommandLine.Core.Specification.IsOption()", file="HelpTextTests.cs", label="Entry CommandLine.Core.Specification.IsOption()", span="10-10"];
m0_14 [cluster="Unk.MapValues", file="HelpTextTests.cs", label="Entry Unk.MapValues", span=""];
m0_10 [cluster="System.Type.GetProperties()", file="HelpTextTests.cs", label="Entry System.Type.GetProperties()", span="0-0"];
m0_9 [cluster="System.Collections.Generic.List<T>.List()", file="HelpTextTests.cs", label="Entry System.Collections.Generic.List<T>.List()", span="0-0"];
m1_0 [cluster="CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string)", file="InstanceBuilder.cs", label="Entry CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string)", span="18-18"];
m1_1 [cluster="CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string)", file="InstanceBuilder.cs", label="Exit CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string)", span="18-18"];
m1_2 [cluster="CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string)", file="InstanceBuilder.cs", label="Entry CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string)", span="29-29"];
m1_3 [cluster="CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string)", file="InstanceBuilder.cs", label="Exit CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string)", span="29-29"];
m1_8 [cluster="CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string, string, string)", file="InstanceBuilder.cs", label="Entry CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string, string, string)", span="68-68"];
m1_9 [cluster="CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string, string, string)", file="InstanceBuilder.cs", label="Exit CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string, string, string)", span="68-68"];
m1_6 [cluster="CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string, string)", file="InstanceBuilder.cs", label="Entry CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string, string)", span="54-54"];
m1_7 [cluster="CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string, string)", file="InstanceBuilder.cs", label="Exit CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string, string)", span="54-54"];
m1_4 [cluster="CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string)", file="InstanceBuilder.cs", label="Entry CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string)", span="41-41"];
m1_5 [cluster="CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string)", file="InstanceBuilder.cs", label="Exit CommandLine.Text.AssemblyLicenseAttribute.AssemblyLicenseAttribute(string, string, string)", span="41-41"];
m2_27 [cluster="System.Linq.Enumerable.Empty<TResult>()", file="InstanceChooser.cs", label="Entry System.Linq.Enumerable.Empty<TResult>()", span="0-0"];
m2_28 [cluster="CommandLine.Core.OptionSpecification.FromAttribute(CommandLine.OptionAttribute, System.Type, System.Collections.Generic.IEnumerable<string>)", file="InstanceChooser.cs", label="Entry CommandLine.Core.OptionSpecification.FromAttribute(CommandLine.OptionAttribute, System.Type, System.Collections.Generic.IEnumerable<string>)", span="32-32"];
m2_0 [cluster="CommandLine.Core.Specification.Specification(CommandLine.Core.SpecificationType, bool, CommandLine.Infrastructure.Maybe<int>, CommandLine.Infrastructure.Maybe<int>, CommandLine.Infrastructure.Maybe<object>, System.Type, CommandLine.Core.TargetType)", file="InstanceChooser.cs", label="Entry CommandLine.Core.Specification.Specification(CommandLine.Core.SpecificationType, bool, CommandLine.Infrastructure.Maybe<int>, CommandLine.Infrastructure.Maybe<int>, CommandLine.Infrastructure.Maybe<object>, System.Type, CommandLine.Core.TargetType)", span="35-35"];
m2_1 [cluster="CommandLine.Core.Specification.Specification(CommandLine.Core.SpecificationType, bool, CommandLine.Infrastructure.Maybe<int>, CommandLine.Infrastructure.Maybe<int>, CommandLine.Infrastructure.Maybe<object>, System.Type, CommandLine.Core.TargetType)", file="InstanceChooser.cs", label="this.tag = tag", span="38-38"];
m2_2 [cluster="CommandLine.Core.Specification.Specification(CommandLine.Core.SpecificationType, bool, CommandLine.Infrastructure.Maybe<int>, CommandLine.Infrastructure.Maybe<int>, CommandLine.Infrastructure.Maybe<object>, System.Type, CommandLine.Core.TargetType)", file="InstanceChooser.cs", label="this.required = required", span="39-39"];
m2_3 [cluster="CommandLine.Core.Specification.Specification(CommandLine.Core.SpecificationType, bool, CommandLine.Infrastructure.Maybe<int>, CommandLine.Infrastructure.Maybe<int>, CommandLine.Infrastructure.Maybe<object>, System.Type, CommandLine.Core.TargetType)", file="InstanceChooser.cs", label="this.min = min", span="40-40"];
m2_4 [cluster="CommandLine.Core.Specification.Specification(CommandLine.Core.SpecificationType, bool, CommandLine.Infrastructure.Maybe<int>, CommandLine.Infrastructure.Maybe<int>, CommandLine.Infrastructure.Maybe<object>, System.Type, CommandLine.Core.TargetType)", file="InstanceChooser.cs", label="this.max = max", span="41-41"];
m2_5 [cluster="CommandLine.Core.Specification.Specification(CommandLine.Core.SpecificationType, bool, CommandLine.Infrastructure.Maybe<int>, CommandLine.Infrastructure.Maybe<int>, CommandLine.Infrastructure.Maybe<object>, System.Type, CommandLine.Core.TargetType)", file="InstanceChooser.cs", label="this.defaultValue = defaultValue", span="42-42"];
m2_6 [cluster="CommandLine.Core.Specification.Specification(CommandLine.Core.SpecificationType, bool, CommandLine.Infrastructure.Maybe<int>, CommandLine.Infrastructure.Maybe<int>, CommandLine.Infrastructure.Maybe<object>, System.Type, CommandLine.Core.TargetType)", file="InstanceChooser.cs", label="this.conversionType = conversionType", span="43-43"];
m2_7 [cluster="CommandLine.Core.Specification.Specification(CommandLine.Core.SpecificationType, bool, CommandLine.Infrastructure.Maybe<int>, CommandLine.Infrastructure.Maybe<int>, CommandLine.Infrastructure.Maybe<object>, System.Type, CommandLine.Core.TargetType)", file="InstanceChooser.cs", label="this.targetType = targetType", span="44-44"];
m2_8 [cluster="CommandLine.Core.Specification.Specification(CommandLine.Core.SpecificationType, bool, CommandLine.Infrastructure.Maybe<int>, CommandLine.Infrastructure.Maybe<int>, CommandLine.Infrastructure.Maybe<object>, System.Type, CommandLine.Core.TargetType)", file="InstanceChooser.cs", label="Exit CommandLine.Core.Specification.Specification(CommandLine.Core.SpecificationType, bool, CommandLine.Infrastructure.Maybe<int>, CommandLine.Infrastructure.Maybe<int>, CommandLine.Infrastructure.Maybe<object>, System.Type, CommandLine.Core.TargetType)", span="35-35"];
m2_24 [cluster="System.Collections.Generic.IEnumerable<TSource>.Count<TSource>()", file="InstanceChooser.cs", label="Entry System.Collections.Generic.IEnumerable<TSource>.Count<TSource>()", span="0-0"];
m2_23 [cluster="System.Collections.IEnumerable.OfType<TResult>()", file="InstanceChooser.cs", label="Entry System.Collections.IEnumerable.OfType<TResult>()", span="0-0"];
m2_31 [cluster="CommandLine.Core.ValueSpecification.FromAttribute(CommandLine.ValueAttribute, System.Type)", file="InstanceChooser.cs", label="Entry CommandLine.Core.ValueSpecification.FromAttribute(CommandLine.ValueAttribute, System.Type)", span="18-18"];
m2_26 [cluster="System.Enum.GetNames(System.Type)", file="InstanceChooser.cs", label="Entry System.Enum.GetNames(System.Type)", span="0-0"];
m2_29 [cluster="string.ToLowerInvariant()", file="InstanceChooser.cs", label="Entry string.ToLowerInvariant()", span="0-0"];
m2_9 [cluster="CommandLine.Core.Specification.FromProperty(System.Reflection.PropertyInfo)", file="InstanceChooser.cs", label="Entry CommandLine.Core.Specification.FromProperty(System.Reflection.PropertyInfo)", span="82-82"];
m2_10 [cluster="CommandLine.Core.Specification.FromProperty(System.Reflection.PropertyInfo)", file="InstanceChooser.cs", label="var attrs = property.GetCustomAttributes(true)", span="84-84"];
m2_13 [cluster="CommandLine.Core.Specification.FromProperty(System.Reflection.PropertyInfo)", file="InstanceChooser.cs", label="var spec = OptionSpecification.FromAttribute(oa.Single(), property.PropertyType,\r\n                    property.PropertyType.IsEnum\r\n                        ? Enum.GetNames(property.PropertyType)\r\n                        : Enumerable.Empty<string>())", span="88-91"];
m2_15 [cluster="CommandLine.Core.Specification.FromProperty(System.Reflection.PropertyInfo)", file="InstanceChooser.cs", label="return spec.WithLongName(property.Name.ToLowerInvariant());", span="94-94"];
m2_19 [cluster="CommandLine.Core.Specification.FromProperty(System.Reflection.PropertyInfo)", file="InstanceChooser.cs", label="return ValueSpecification.FromAttribute(va.Single(), property.PropertyType);", span="102-102"];
m2_11 [cluster="CommandLine.Core.Specification.FromProperty(System.Reflection.PropertyInfo)", file="InstanceChooser.cs", label="var oa = attrs.OfType<OptionAttribute>()", span="85-85"];
m2_17 [cluster="CommandLine.Core.Specification.FromProperty(System.Reflection.PropertyInfo)", file="InstanceChooser.cs", label="var va = attrs.OfType<ValueAttribute>()", span="99-99"];
m2_12 [cluster="CommandLine.Core.Specification.FromProperty(System.Reflection.PropertyInfo)", file="InstanceChooser.cs", label="oa.Count() == 1", span="86-86"];
m2_14 [cluster="CommandLine.Core.Specification.FromProperty(System.Reflection.PropertyInfo)", file="InstanceChooser.cs", label="spec.ShortName.Length == 0 && spec.LongName.Length == 0", span="92-92"];
m2_16 [cluster="CommandLine.Core.Specification.FromProperty(System.Reflection.PropertyInfo)", file="InstanceChooser.cs", label="return spec;", span="96-96"];
m2_18 [cluster="CommandLine.Core.Specification.FromProperty(System.Reflection.PropertyInfo)", file="InstanceChooser.cs", label="va.Count() == 1", span="100-100"];
m2_20 [cluster="CommandLine.Core.Specification.FromProperty(System.Reflection.PropertyInfo)", file="InstanceChooser.cs", label="throw new InvalidOperationException();", span="105-105"];
m2_21 [cluster="CommandLine.Core.Specification.FromProperty(System.Reflection.PropertyInfo)", file="InstanceChooser.cs", label="Exit CommandLine.Core.Specification.FromProperty(System.Reflection.PropertyInfo)", span="82-82"];
m2_22 [cluster="System.Reflection.MemberInfo.GetCustomAttributes(bool)", file="InstanceChooser.cs", label="Entry System.Reflection.MemberInfo.GetCustomAttributes(bool)", span="0-0"];
m2_25 [cluster="System.Collections.Generic.IEnumerable<TSource>.Single<TSource>()", file="InstanceChooser.cs", label="Entry System.Collections.Generic.IEnumerable<TSource>.Single<TSource>()", span="0-0"];
m2_30 [cluster="CommandLine.Core.OptionSpecification.WithLongName(string)", file="InstanceChooser.cs", label="Entry CommandLine.Core.OptionSpecification.WithLongName(string)", span="20-20"];
m2_32 [cluster="System.InvalidOperationException.InvalidOperationException()", file="InstanceChooser.cs", label="Entry System.InvalidOperationException.InvalidOperationException()", span="0-0"];
m2_33 [file="InstanceChooser.cs", label="CommandLine.Core.Specification", span=""];
m3_11 [cluster="CommandLine.Infrastructure.Maybe.Nothing<T>()", file="Tokenizer.cs", label="Entry CommandLine.Infrastructure.Maybe.Nothing<T>()", span="63-63"];
m3_10 [cluster="System.Collections.Generic.IEnumerable<TSource>.Contains<TSource>(TSource)", file="Tokenizer.cs", label="Entry System.Collections.Generic.IEnumerable<TSource>.Contains<TSource>(TSource)", span="0-0"];
m3_13 [cluster="CommandLine.Infrastructure.Maybe.Just<T>(T)", file="Tokenizer.cs", label="Entry CommandLine.Infrastructure.Maybe.Just<T>(T)", span="68-68"];
m3_14 [cluster="CommandLine.Tests.Unit.Core.SwitchTests.Partition_switch_values()", file="Tokenizer.cs", label="Entry CommandLine.Tests.Unit.Core.SwitchTests.Partition_switch_values()", span="28-28"];
m3_15 [cluster="CommandLine.Tests.Unit.Core.SwitchTests.Partition_switch_values()", color=green, community=0, file="Tokenizer.cs", label="var expected = new [] { Token.Name(''x'') }", prediction=0, span="30-30"];
m3_16 [cluster="CommandLine.Tests.Unit.Core.SwitchTests.Partition_switch_values()", file="Tokenizer.cs", label="var result = Switch.Partition(\r\n                new []\r\n                    {\r\n                        Token.Name(''str''), Token.Value(''strvalue''), Token.Value(''freevalue''),\r\n                        Token.Name(''x''), Token.Value(''freevalue2'')\r\n                    },\r\n                name =>\r\n                    new[] { ''x'', ''switch'' }.Contains(name)\r\n                        ? Maybe.Just(TypeDescriptor.Create(TargetType.Boolean, Maybe.Nothing<int>()))\r\n                        : Maybe.Nothing<TypeDescriptor>())", span="32-41"];
m3_17 [cluster="CommandLine.Tests.Unit.Core.SwitchTests.Partition_switch_values()", file="Tokenizer.cs", label="expected.ShouldAllBeEquivalentTo(result)", span="43-43"];
m3_18 [cluster="CommandLine.Tests.Unit.Core.SwitchTests.Partition_switch_values()", file="Tokenizer.cs", label="Exit CommandLine.Tests.Unit.Core.SwitchTests.Partition_switch_values()", span="28-28"];
m3_12 [cluster="CommandLine.Core.TypeDescriptor.Create(CommandLine.Core.TargetType, CommandLine.Infrastructure.Maybe<int>)", file="Tokenizer.cs", label="Entry CommandLine.Core.TypeDescriptor.Create(CommandLine.Core.TargetType, CommandLine.Infrastructure.Maybe<int>)", span="29-29"];
m3_6 [cluster="lambda expression", file="Tokenizer.cs", label="t.IsName() && info.Tag == TypeDescriptorKind.Boolean", span="16-16"];
m3_7 [cluster="lambda expression", file="Tokenizer.cs", label="Exit lambda expression", span="16-16"];
m3_5 [cluster="CommandLine.Core.Switch.Partition(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, System.Func<string, CommandLine.Infrastructure.Maybe<CommandLine.Core.TypeDescriptor>>)", file="Tokenizer.cs", label="Entry CommandLine.Core.Switch.Partition(System.Collections.Generic.IEnumerable<CommandLine.Core.Token>, System.Func<string, CommandLine.Infrastructure.Maybe<CommandLine.Core.TypeDescriptor>>)", span="11-11"];
m3_21 [cluster="lambda expression", file="Tokenizer.cs", label="Entry lambda expression", span="38-41"];
m3_23 [cluster="lambda expression", file="Tokenizer.cs", label="Exit lambda expression", span="38-41"];
m3_22 [cluster="lambda expression", file="Tokenizer.cs", label="new[] { ''x'', ''switch'' }.Contains(name)\r\n                        ? Maybe.Just(TypeDescriptor.Create(TargetType.Boolean, Maybe.Nothing<int>()))\r\n                        : Maybe.Nothing<TypeDescriptor>()", span="39-41"];
m3_8 [cluster="CommandLine.Core.Token.IsName()", file="Tokenizer.cs", label="Entry CommandLine.Core.Token.IsName()", span="68-68"];
m3_9 [cluster="lambda expression", file="Tokenizer.cs", label=t, span=""];
m3_19 [cluster="CommandLine.Core.Token.Name(string)", file="Tokenizer.cs", label="Entry CommandLine.Core.Token.Name(string)", span="19-19"];
m3_0 [cluster="CommandLine.Tests.Unit.Core.SwitchTests.Partition_switch_values_from_empty_token_sequence()", file="Tokenizer.cs", label="Entry CommandLine.Tests.Unit.Core.SwitchTests.Partition_switch_values_from_empty_token_sequence()", span="13-13"];
m3_1 [cluster="CommandLine.Tests.Unit.Core.SwitchTests.Partition_switch_values_from_empty_token_sequence()", file="Tokenizer.cs", label="var expected = new Token[] { }", span="15-15"];
m3_2 [cluster="CommandLine.Tests.Unit.Core.SwitchTests.Partition_switch_values_from_empty_token_sequence()", file="Tokenizer.cs", label="var result = Switch.Partition(\r\n                new Token[] { },\r\n                name =>\r\n                    new[] { ''x'', ''switch'' }.Contains(name)\r\n                        ? Maybe.Just(TypeDescriptor.Create(TargetType.Boolean, Maybe.Nothing<int>()))\r\n                        : Maybe.Nothing<TypeDescriptor>())", span="17-22"];
m3_4 [cluster="CommandLine.Tests.Unit.Core.SwitchTests.Partition_switch_values_from_empty_token_sequence()", file="Tokenizer.cs", label="Exit CommandLine.Tests.Unit.Core.SwitchTests.Partition_switch_values_from_empty_token_sequence()", span="13-13"];
m3_20 [cluster="CommandLine.Core.Token.Value(string)", file="Tokenizer.cs", label="Entry CommandLine.Core.Token.Value(string)", span="24-24"];
m3_3 [cluster="CommandLine.Tests.Unit.Core.SwitchTests.Partition_switch_values_from_empty_token_sequence()", file="Tokenizer.cs", label="expected.ShouldAllBeEquivalentTo(result)", span="24-24"];
m4_47 [cluster="CommandLine.Core.SpecificationProperty.WithValue(CommandLine.Infrastructure.Maybe<object>)", file="TokenPartitioner.cs", label="Entry CommandLine.Core.SpecificationProperty.WithValue(CommandLine.Infrastructure.Maybe<object>)", span="18-18"];
m4_36 [cluster="System.Type.IsScalar()", file="TokenPartitioner.cs", label="Entry System.Type.IsScalar()", span="33-33"];
m4_28 [cluster="System.Collections.Generic.IEnumerable<TSource>.Empty<TSource>()", file="TokenPartitioner.cs", label="Entry System.Collections.Generic.IEnumerable<TSource>.Empty<TSource>()", span="81-81"];
m4_6 [cluster="Unk.>", file="TokenPartitioner.cs", label="Entry Unk.>", span=""];
m4_7 [cluster="Unk.Create", file="TokenPartitioner.cs", label="Entry Unk.Create", span=""];
m4_0 [cluster="CommandLine.Core.ValueMapper.MapValues(System.Collections.Generic.IEnumerable<CommandLine.Core.SpecificationProperty>, System.Collections.Generic.IEnumerable<string>, System.Func<System.Collections.Generic.IEnumerable<string>, System.Type, bool, CommandLine.Infrastructure.Maybe<object>>)", file="TokenPartitioner.cs", label="Entry CommandLine.Core.ValueMapper.MapValues(System.Collections.Generic.IEnumerable<CommandLine.Core.SpecificationProperty>, System.Collections.Generic.IEnumerable<string>, System.Func<System.Collections.Generic.IEnumerable<string>, System.Type, bool, CommandLine.Infrastructure.Maybe<object>>)", span="11-11"];
m4_1 [cluster="CommandLine.Core.ValueMapper.MapValues(System.Collections.Generic.IEnumerable<CommandLine.Core.SpecificationProperty>, System.Collections.Generic.IEnumerable<string>, System.Func<System.Collections.Generic.IEnumerable<string>, System.Type, bool, CommandLine.Infrastructure.Maybe<object>>)", color=green, community=0, file="TokenPartitioner.cs", label="var propAndErrors = MapValuesImpl(specProps, values, converter)", prediction=1, span="16-16"];
m4_2 [cluster="CommandLine.Core.ValueMapper.MapValues(System.Collections.Generic.IEnumerable<CommandLine.Core.SpecificationProperty>, System.Collections.Generic.IEnumerable<string>, System.Func<System.Collections.Generic.IEnumerable<string>, System.Type, bool, CommandLine.Infrastructure.Maybe<object>>)", color=green, community=0, file="TokenPartitioner.cs", label="return StatePair.Create(\r\n                propAndErrors.Select(pe => pe.Item1),\r\n                propAndErrors.Select(pe => pe.Item2)\r\n                    .OfType<Just<Error>>().Select(e => e.Value)\r\n                );", prediction=2, span="18-22"];
m4_3 [cluster="CommandLine.Core.ValueMapper.MapValues(System.Collections.Generic.IEnumerable<CommandLine.Core.SpecificationProperty>, System.Collections.Generic.IEnumerable<string>, System.Func<System.Collections.Generic.IEnumerable<string>, System.Type, bool, CommandLine.Infrastructure.Maybe<object>>)", file="TokenPartitioner.cs", label="Exit CommandLine.Core.ValueMapper.MapValues(System.Collections.Generic.IEnumerable<CommandLine.Core.SpecificationProperty>, System.Collections.Generic.IEnumerable<string>, System.Func<System.Collections.Generic.IEnumerable<string>, System.Type, bool, CommandLine.Infrastructure.Maybe<object>>)", span="11-11"];
m4_35 [cluster="System.Tuple.Create<T1, T2>(T1, T2)", file="TokenPartitioner.cs", label="Entry System.Tuple.Create<T1, T2>(T1, T2)", span="0-0"];
m4_52 [cluster="CommandLine.SequenceOutOfRangeError.SequenceOutOfRangeError(CommandLine.NameInfo)", file="TokenPartitioner.cs", label="Entry CommandLine.SequenceOutOfRangeError.SequenceOutOfRangeError(CommandLine.NameInfo)", span="316-316"];
m4_41 [cluster="lambda expression", file="TokenPartitioner.cs", label="Entry lambda expression", span="35-35"];
m4_8 [cluster="lambda expression", file="TokenPartitioner.cs", label="Entry lambda expression", span="19-19"];
m4_11 [cluster="lambda expression", file="TokenPartitioner.cs", label="Entry lambda expression", span="20-20"];
m4_14 [cluster="lambda expression", file="TokenPartitioner.cs", label="Entry lambda expression", span="21-21"];
m4_9 [cluster="lambda expression", color=green, community=0, file="TokenPartitioner.cs", label="pe.Item1", prediction=3, span="19-19"];
m4_10 [cluster="lambda expression", file="TokenPartitioner.cs", label="Exit lambda expression", span="19-19"];
m4_13 [cluster="lambda expression", file="TokenPartitioner.cs", label="Exit lambda expression", span="20-20"];
m4_12 [cluster="lambda expression", file="TokenPartitioner.cs", label="pe.Item2", span="20-20"];
m4_16 [cluster="lambda expression", file="TokenPartitioner.cs", label="Exit lambda expression", span="21-21"];
m4_15 [cluster="lambda expression", file="TokenPartitioner.cs", label="e.Value", span="21-21"];
m4_44 [cluster="lambda expression", file="TokenPartitioner.cs", label="Entry lambda expression", span="46-46"];
m4_45 [cluster="lambda expression", file="TokenPartitioner.cs", label="Tuple.Create(pt.WithValue(Maybe.Just(converted)), Maybe.Nothing<Error>())", span="46-46"];
m4_46 [cluster="lambda expression", file="TokenPartitioner.cs", label="Exit lambda expression", span="46-46"];
m4_42 [cluster="lambda expression", file="TokenPartitioner.cs", label=n, span="35-35"];
m4_43 [cluster="lambda expression", file="TokenPartitioner.cs", label="Exit lambda expression", span="35-35"];
m4_29 [cluster="System.Collections.Generic.IEnumerable<TSource>.First<TSource>()", file="TokenPartitioner.cs", label="Entry System.Collections.Generic.IEnumerable<TSource>.First<TSource>()", span="0-0"];
m4_40 [cluster="System.Collections.Generic.IEnumerable<TSource>.Skip<TSource>(int)", file="TokenPartitioner.cs", label="Entry System.Collections.Generic.IEnumerable<TSource>.Skip<TSource>(int)", span="0-0"];
m4_33 [cluster="System.Collections.Generic.IEnumerable<TSource>.Take<TSource>(int)", file="TokenPartitioner.cs", label="Entry System.Collections.Generic.IEnumerable<TSource>.Take<TSource>(int)", span="0-0"];
m4_37 [cluster="System.Func<T1, T2, T3, TResult>.Invoke(T1, T2, T3)", file="TokenPartitioner.cs", label="Entry System.Func<T1, T2, T3, TResult>.Invoke(T1, T2, T3)", span="0-0"];
m4_51 [cluster="CommandLine.Core.Specification.IsMinNotSpecified()", file="TokenPartitioner.cs", label="Entry CommandLine.Core.Specification.IsMinNotSpecified()", span="70-70"];
m4_34 [cluster="CommandLine.Core.ValueMapper.MakeErrorInCaseOfMinConstraint(CommandLine.Core.Specification)", file="TokenPartitioner.cs", label="Entry CommandLine.Core.ValueMapper.MakeErrorInCaseOfMinConstraint(CommandLine.Core.Specification)", span="56-56"];
m4_49 [cluster="CommandLine.Core.ValueMapper.MakeErrorInCaseOfMinConstraint(CommandLine.Core.Specification)", file="TokenPartitioner.cs", label="return !specification.IsMinNotSpecified()\r\n                ? Maybe.Just<Error>(new SequenceOutOfRangeError(NameInfo.EmptyName))\r\n                : Maybe.Nothing<Error>();", span="58-60"];
m4_50 [cluster="CommandLine.Core.ValueMapper.MakeErrorInCaseOfMinConstraint(CommandLine.Core.Specification)", file="TokenPartitioner.cs", label="Exit CommandLine.Core.ValueMapper.MakeErrorInCaseOfMinConstraint(CommandLine.Core.Specification)", span="56-56"];
m4_39 [cluster="CommandLine.Infrastructure.Maybe.Just<T>(T)", file="TokenPartitioner.cs", label="Entry CommandLine.Infrastructure.Maybe.Just<T>(T)", span="71-71"];
m4_5 [cluster="Unk.Select", file="TokenPartitioner.cs", label="Entry Unk.Select", span=""];
m4_38 [cluster="CommandLine.BadFormatConversionError.BadFormatConversionError(CommandLine.NameInfo)", file="TokenPartitioner.cs", label="Entry CommandLine.BadFormatConversionError.BadFormatConversionError(CommandLine.NameInfo)", span="305-305"];
m4_48 [cluster="CommandLine.Infrastructure.Maybe.Nothing<T>()", file="TokenPartitioner.cs", label="Entry CommandLine.Infrastructure.Maybe.Nothing<T>()", span="66-66"];
m4_30 [cluster="CommandLine.Core.Specification.GetMaxValueCount()", file="TokenPartitioner.cs", label="Entry CommandLine.Core.Specification.GetMaxValueCount()", span="51-51"];
m4_31 [cluster="System.Collections.Generic.IEnumerable<TSource>.Count<TSource>()", file="TokenPartitioner.cs", label="Entry System.Collections.Generic.IEnumerable<TSource>.Count<TSource>()", span="0-0"];
m4_4 [cluster="CommandLine.Core.ValueMapper.MapValuesImpl(System.Collections.Generic.IEnumerable<CommandLine.Core.SpecificationProperty>, System.Collections.Generic.IEnumerable<string>, System.Func<System.Collections.Generic.IEnumerable<string>, System.Type, bool, CommandLine.Infrastructure.Maybe<object>>)", file="TokenPartitioner.cs", label="Entry CommandLine.Core.ValueMapper.MapValuesImpl(System.Collections.Generic.IEnumerable<CommandLine.Core.SpecificationProperty>, System.Collections.Generic.IEnumerable<string>, System.Func<System.Collections.Generic.IEnumerable<string>, System.Type, bool, CommandLine.Infrastructure.Maybe<object>>)", span="25-25"];
m4_25 [cluster="CommandLine.Core.ValueMapper.MapValuesImpl(System.Collections.Generic.IEnumerable<CommandLine.Core.SpecificationProperty>, System.Collections.Generic.IEnumerable<string>, System.Func<System.Collections.Generic.IEnumerable<string>, System.Type, bool, CommandLine.Infrastructure.Maybe<object>>)", file="TokenPartitioner.cs", label="MapValuesImpl(specProps.Skip(1), values.Skip(taken.Count()), converter)", span="50-50"];
m4_17 [cluster="CommandLine.Core.ValueMapper.MapValuesImpl(System.Collections.Generic.IEnumerable<CommandLine.Core.SpecificationProperty>, System.Collections.Generic.IEnumerable<string>, System.Func<System.Collections.Generic.IEnumerable<string>, System.Type, bool, CommandLine.Infrastructure.Maybe<object>>)", file="TokenPartitioner.cs", label="specProps.Empty()", span="30-30"];
m4_18 [cluster="CommandLine.Core.ValueMapper.MapValuesImpl(System.Collections.Generic.IEnumerable<CommandLine.Core.SpecificationProperty>, System.Collections.Generic.IEnumerable<string>, System.Func<System.Collections.Generic.IEnumerable<string>, System.Type, bool, CommandLine.Infrastructure.Maybe<object>>)", file="TokenPartitioner.cs", label="yield break;", span="32-32"];
m4_22 [cluster="CommandLine.Core.ValueMapper.MapValuesImpl(System.Collections.Generic.IEnumerable<CommandLine.Core.SpecificationProperty>, System.Collections.Generic.IEnumerable<string>, System.Func<System.Collections.Generic.IEnumerable<string>, System.Type, bool, CommandLine.Infrastructure.Maybe<object>>)", file="TokenPartitioner.cs", label="yield return\r\n                    Tuple.Create(pt, MakeErrorInCaseOfMinConstraint(pt.Specification));", span="38-39"];
m4_23 [cluster="CommandLine.Core.ValueMapper.MapValuesImpl(System.Collections.Generic.IEnumerable<CommandLine.Core.SpecificationProperty>, System.Collections.Generic.IEnumerable<string>, System.Func<System.Collections.Generic.IEnumerable<string>, System.Type, bool, CommandLine.Infrastructure.Maybe<object>>)", file="TokenPartitioner.cs", label="yield break;", span="40-40"];
m4_24 [cluster="CommandLine.Core.ValueMapper.MapValuesImpl(System.Collections.Generic.IEnumerable<CommandLine.Core.SpecificationProperty>, System.Collections.Generic.IEnumerable<string>, System.Func<System.Collections.Generic.IEnumerable<string>, System.Type, bool, CommandLine.Infrastructure.Maybe<object>>)", file="TokenPartitioner.cs", label="yield return\r\n                converter(taken, pt.Property.PropertyType, pt.Specification.ConversionType.IsScalar())\r\n                    .Return(\r\n                        converted => Tuple.Create(pt.WithValue(Maybe.Just(converted)), Maybe.Nothing<Error>()),\r\n                        Tuple.Create<SpecificationProperty, Maybe<Error>>(\r\n                            pt, Maybe.Just<Error>(new BadFormatConversionError(NameInfo.EmptyName))));", span="43-48"];
m4_26 [cluster="CommandLine.Core.ValueMapper.MapValuesImpl(System.Collections.Generic.IEnumerable<CommandLine.Core.SpecificationProperty>, System.Collections.Generic.IEnumerable<string>, System.Func<System.Collections.Generic.IEnumerable<string>, System.Type, bool, CommandLine.Infrastructure.Maybe<object>>)", file="TokenPartitioner.cs", label="yield return value;", span="52-52"];
m4_19 [cluster="CommandLine.Core.ValueMapper.MapValuesImpl(System.Collections.Generic.IEnumerable<CommandLine.Core.SpecificationProperty>, System.Collections.Generic.IEnumerable<string>, System.Func<System.Collections.Generic.IEnumerable<string>, System.Type, bool, CommandLine.Infrastructure.Maybe<object>>)", file="TokenPartitioner.cs", label="var pt = specProps.First()", span="34-34"];
m4_20 [cluster="CommandLine.Core.ValueMapper.MapValuesImpl(System.Collections.Generic.IEnumerable<CommandLine.Core.SpecificationProperty>, System.Collections.Generic.IEnumerable<string>, System.Func<System.Collections.Generic.IEnumerable<string>, System.Type, bool, CommandLine.Infrastructure.Maybe<object>>)", file="TokenPartitioner.cs", label="var taken = values.Take(pt.Specification.GetMaxValueCount().Return(n => n, values.Count()))", span="35-35"];
m4_21 [cluster="CommandLine.Core.ValueMapper.MapValuesImpl(System.Collections.Generic.IEnumerable<CommandLine.Core.SpecificationProperty>, System.Collections.Generic.IEnumerable<string>, System.Func<System.Collections.Generic.IEnumerable<string>, System.Type, bool, CommandLine.Infrastructure.Maybe<object>>)", file="TokenPartitioner.cs", label="taken.Empty()", span="36-36"];
m4_27 [cluster="CommandLine.Core.ValueMapper.MapValuesImpl(System.Collections.Generic.IEnumerable<CommandLine.Core.SpecificationProperty>, System.Collections.Generic.IEnumerable<string>, System.Func<System.Collections.Generic.IEnumerable<string>, System.Type, bool, CommandLine.Infrastructure.Maybe<object>>)", file="TokenPartitioner.cs", label="Exit CommandLine.Core.ValueMapper.MapValuesImpl(System.Collections.Generic.IEnumerable<CommandLine.Core.SpecificationProperty>, System.Collections.Generic.IEnumerable<string>, System.Func<System.Collections.Generic.IEnumerable<string>, System.Type, bool, CommandLine.Infrastructure.Maybe<object>>)", span="25-25"];
m4_32 [cluster="CommandLine.Infrastructure.Maybe<T1>.Return<T1, T2>(System.Func<T1, T2>, T2)", file="TokenPartitioner.cs", label="Entry CommandLine.Infrastructure.Maybe<T1>.Return<T1, T2>(System.Func<T1, T2>, T2)", span="103-103"];
m4_53 [file="TokenPartitioner.cs", label=pt, span=""];
m0_2 -> m0_16  [color=darkseagreen4, key=1, label="lambda expression", style=dashed];
m2_9 -> m2_15  [color=darkseagreen4, key=1, label="System.Reflection.PropertyInfo", style=dashed];
m2_9 -> m2_19  [color=darkseagreen4, key=1, label="System.Reflection.PropertyInfo", style=dashed];
m2_13 -> m2_15  [color=darkseagreen4, key=1, label=spec, style=dashed];
m2_13 -> m2_16  [color=darkseagreen4, key=1, label=spec, style=dashed];
m2_17 -> m2_19  [color=darkseagreen4, key=1, label=va, style=dashed];
m3_15 -> m3_17  [color=green, key=1, label=expected, style=dashed];
m3_16 -> m3_21  [color=darkseagreen4, key=1, label="lambda expression", style=dashed];
m3_9 -> m3_6  [color=darkseagreen4, key=1, label=t, style=dashed];
m3_1 -> m3_5  [color=darkseagreen4, key=1, label="lambda expression", style=dashed];
m3_1 -> m3_6  [color=darkseagreen4, key=1, label=t, style=dashed];
m3_2 -> m3_7  [color=darkseagreen4, key=1, label="lambda expression", style=dashed];
m4_2 -> m4_8  [color=green, key=1, label="lambda expression", style=dashed];
m4_2 -> m4_11  [color=green, key=1, label="lambda expression", style=dashed];
m4_2 -> m4_14  [color=green, key=1, label="lambda expression", style=dashed];
m4_4 -> m4_25  [color=darkseagreen4, key=1, label="System.Collections.Generic.IEnumerable<CommandLine.Core.SpecificationProperty>", style=dashed];
m4_24 -> m4_44  [color=darkseagreen4, key=1, label="lambda expression", style=dashed];
m4_19 -> m4_22  [color=darkseagreen4, key=1, label=pt, style=dashed];
m4_19 -> m4_24  [color=darkseagreen4, key=1, label=pt, style=dashed];
m4_19 -> m4_45  [color=darkseagreen4, key=1, label=pt, style=dashed];
m4_20 -> m4_25  [color=darkseagreen4, key=1, label=taken, style=dashed];
m4_20 -> m4_24  [color=darkseagreen4, key=1, label=taken, style=dashed];
m4_20 -> m4_41  [color=darkseagreen4, key=1, label="lambda expression", style=dashed];
m4_53 -> m4_45  [color=darkseagreen4, key=1, label=pt, style=dashed];
}
